{
  parserClass="me.hardcoded.arucas.language.ArucasParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Arucas"
  psiImplClassSuffix="Impl"
  psiPackage="me.hardcoded.arucas.psi"
  psiImplPackage="me.hardcoded.arucas.psi.impl"

  elementTypeHolderClass="me.hardcoded.arucas.psi.ArucasTypes"
  elementTypeClass="me.hardcoded.arucas.psi.ArucasElementType"
  tokenTypeClass="me.hardcoded.arucas.psi.ArucasTokenType"

  tokens = [
    COMMENT='regexp://.*[^\n\r\f]|/\*(.|[\r\n\f])*?\*/'
    WHITESPACE='regexp:\s+'
    NUMBER='regexp:[0-9]+(\\.[0-9]+)?'
    VALUE_KEYWORD='regexp:true|false|null|this'
    KW_IF="if"
    KW_ELSE="else"
    KW_FOR="for"
    KW_FOREACH="foreach"
    KW_WHILE="while"
    KW_TRY="try"
    KW_CATCH="catch"
    KW_FUN="fun"
    KW_CLASS="class"
    KW_OPERATOR="operator"
    KW_NEW="new"
    KW_STATIC="static"
    KW_VAR="var"
    KW_SWITCH="switch"
    KW_CASE="case"
    KW_DEFAULT="default"
    KW_RETURN="return"
    KW_BREAK="break"
    KW_CONTINUE="continue"
    IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")|(\"([^\"\\]|\\.)*\"|'([^'\\]|\\.)*\")"
    OP_LOGICAL_OR="||"
    OP_LOGICAL_AND="&&"
    OP_EQUALS="=="
    OP_NOTEQUALS="!="
    OP_MORETHANEQ=">="
    OP_MORETHAN=">"
    OP_LESSTHANEQ="<="
    OP_LESSTHAN="<"
    OP_PLUS="+"
    OP_MINUS="-"
    OP_MUL="*"
    OP_DIV="/"
    OP_POW="^"
    OP_NOT="!"
    OP_MM="--"
    OP_PP="++"
    COMMA=","
    SEMICOLON=";"
    ASSIGNMENT="="
    POINTER="->"
    DOT="."
    COLON=":"
    LPAREN="("
    RPAREN=")"
    LBRACK="["
    RBRACK="]"
    LBRACE="{"
    RBRACE="}"
  ]
}

// ROOT
arucas ::= Statement *

CodeBlock ::= '{' ( '}' | Statement+ '}' )
Statement ::= CodeBlock
  | ';'
  | IfStatement
  | WhileStatement
  | ClassDeclaration
  | FunctionStatement
  | TryStatement
  | ForEachStatement
  | ForStatement
  | SwitchStatement
  | ReturnStatement
  | ContinueStatement
  | BreakStatement
  | ExpressionStatement

IdentifierName ::= IDENTIFIER {
  mixin="me.hardcoded.arucas.psi.impl.ArucasNamedElementImpl"
  implements="me.hardcoded.arucas.psi.ArucasNamedElement"
  methods=[setName getNameIdentifier]
}

ReturnStatement ::= 'return' SizeExpression? ';' {extends=Statement}
ContinueStatement ::= 'continue' ';' {extends=Statement}
BreakStatement ::= 'break' ';' {extends=Statement}
ExpressionStatement ::= Expression ';' {extends=Statement}

IfStatement ::= 'if' '(' Expression ')' Statement ElseStatement? {extends=Statement}
ElseStatement ::= 'else' Statement {extends=Statement}
WhileStatement ::= 'while' '(' Expression ')' Statement {extends=Statement}

/* Class Statement */
ClassDeclaration ::= 'class' IdentifierName ClassCodeBlock {extends=Statement}
ClassCodeBlock ::= '{' ClassBodyStatement* '}' {extends=Statement}
private ClassBodyStatement ::= ClassMember
  | ClassConstructor
  | ClassMethod
  | ClassOperator {extends=Statement}

Operator ::= '+' | '-' | '*' | '/' | '^' | '!' | '==' | '!='
  | '++' | '--' | '&&' | '||' | '>=' | '<=' | '>' | '<'

ClassConstructor ::= IdentifierName Arguments CodeBlock
ClassOperator ::= 'operator' Operator OperatorArguments CodeBlock { methods=[operator="OPERATOR[0]"] }
ClassMethod ::= FunctionModifiers 'fun' IdentifierName Arguments CodeBlock
ClassMember ::= FunctionModifiers 'var' IdentifierName ['=' Expression] ';'
FunctionModifiers ::= ( 'static'? ) {
  mixin="me.hardcoded.arucas.psi.impl.ArucasModifierElementImpl"
  implements="me.hardcoded.arucas.psi.ArucasModifierElement"
  methods=[isStatic]
}

Arguments ::= '(' [ Argument (',' Argument)* ] ')'
Argument ::= IdentifierName

OperatorArguments ::= Arguments

/* Function Statement */
FunctionStatement ::= 'fun' IdentifierName Arguments CodeBlock {extends=Statement}
TryStatement ::= 'try' Statement 'catch' '(' IdentifierName ')' Statement {
  extends=Statement
  methods=[
    TRY_BODY="Statement[0]"
    CATCH_BODY="Statement[1]"
  ]
}

/* For Statements */
ForEachStatement ::= 'foreach' '(' IdentifierName ':' MemberExpression ')' Statement {extends=Statement}
ForStatement ::= 'for' '(' Expression? ';' Expression? ';' Expression? ')' Statement {extends=Statement}

/* Switch Statement */
SwitchStatement ::= 'switch' '(' Expression ')' SwitchCodeBlock {extends=Statement}
SwitchCodeBlock ::= '{' CaseStatement* '}' {extends=Statement}
CaseStatement ::= ('default' | 'case' CaseValues) '->' Statement

CaseValues ::= CaseValue (',' CaseValue)*
CaseValue ::= CaseString | CaseNumber
private CaseString ::= STRING
private CaseNumber ::= ['-'] NUMBER

/* Expressions */
Expression ::= ModifyVariable
  | SizeExpression

private ModifyVariable ::= IdentifierName ModifyOp
private ModifyOp ::= '++' | '--' | '=' Expression

private SizeExpression ::= ComparisonExpression [SizeOp SizeExpression]
private SizeOp ::= '&&' | '||'

private ComparisonExpression ::= '!' ComparisonExpression
  | ArithmeticExpression [ComparisonOp ArithmeticExpression]
private ComparisonOp ::= '==' | '!=' | '<' | '>' | '<=' | '>='

ArithmeticExpression ::= TermExpression [ArithmeticOp ArithmeticExpression] {extends=Expression}
private ArithmeticOp ::= '+' | '-'

private TermExpression ::= FactorExpression [TermOp TermExpression]
private TermOp ::= '*' | '/'

private FactorExpression ::= UnaryFactorExpression
  | PowerExpression
private FactorOp ::= '+' | '-'
UnaryFactorExpression ::= FactorOp FactorExpression {extends=Expression}

private PowerExpression ::= CallExpression ['^' FactorExpression]
private CallExpression ::= MemberExpression [CallArguments]
CallArguments ::= '(' [ Expression (',' Expression)* ] ')'

private MemberExpression ::= AtomExpression [MemberLoop]
private MemberLoop ::= '.' AtomExpression MemberOp
private MemberOp ::= CallArguments [MemberLoop]
  | '=' Expression
  | '++'
  | '--'
  | [MemberLoop]

private AtomExpression ::= Atom
  | ListExpression
  | MapExpression
  | FunctionLambda
  | NewExpression
  | '(' Expression ')'

// TODO: Add recovery tokens
ListExpression ::= '[' [ListElements] ']' {extends=Expression}
private ListElements ::= Expression (',' Expression)*
MapExpression ::= '{' [MapElements] '}' {extends=Expression}
private MapElements ::= MapEntry (',' MapEntry)*
MapEntry ::= Expression ':' Expression {
  methods=[
    key="Expression[0]"
    value="Expression[1]"
  ]
}

NewExpression ::= 'new' IdentifierName CallArguments {extends=Expression}
FunctionLambda ::= 'fun' Arguments CodeBlock {extends=Expression}
Atom ::= IdentifierName
  | VALUE_KEYWORD
  | STRING
  | NUMBER {extends=Expression}
