{
  parserClass="me.hardcoded.arucas.language.ArucasParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Arucas"
  psiImplClassSuffix="Impl"
  psiPackage="me.hardcoded.arucas.psi"
  psiImplPackage="me.hardcoded.arucas.psi.impl"

  elementTypeHolderClass="me.hardcoded.arucas.psi.ArucasTypes"
  elementTypeClass="me.hardcoded.arucas.psi.ArucasElementType"
  tokenTypeClass="me.hardcoded.arucas.psi.ArucasTokenType"

  tokens = [
    COMMENT='regexp://.*|/\*(.|[\r\n\f])*?\*/'
    WHITESPACE='regexp:\s+'
    NUMBER='regexp:[0-9]+(\\.[0-9]+)?'
    VALUE_KEYWORD='regexp:true|false|null|this'
    KEYWORD='regexp:if|else|foreach|for|while|try|catch|fun|class|operator|new|static|var|switch|case|default|return|break|continue'
    IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")|(\"([^\"\\]|\\.)*\"|'([^'\\]|\\.)*\")"
    SYNTAX='regexp::|\.|==|!=|\(|\)|\[|]|\{|}|>=|<=|=|>|<|\|\||&&|->'
    DELIMITER='regexp:[;,]'
    OPERATOR='regexp:--|\+\+|\+|-|\*|/|\^|!'
  ]
}

// ROOT
arucas ::= Statements *

private Statements ::= '{' ('}' | Statement* '}') | Statement
Statement ::= '{' Statements '}'
  | 'if' IfStatement
  | 'while' WhileStatement
  | 'class' ClassStatement
  | 'fun' FunctionStatement
  | 'try' TryStatement
  | 'foreach' ForEachStatement
  | 'for' ForStatement
  | 'switch' SwitchStatement
  | 'return' [SizeExpression] ';'
  | 'continue' ';'
  | 'break' ';'
  | [Expression] ';'

IfStatement ::= '(' Expression ')' Statements ['else' Statements]
WhileStatement ::= '(' Expression ')' Statements

/* Class Statement */
ClassStatement ::= IDENTIFIER '{' ClassBodyStatement* '}'
private ClassBodyStatement ::= ClassMember
  | ClassConstructor
  | ClassMethod
  | ClassOperator

ClassConstructor ::= IDENTIFIER '(' [Arguments] ')' '{' Statement* '}'
ClassOperator ::= 'operator' OPERATOR '(' [Arguments] ')' '{' Statement* '}' { methods=[operator="OPERATOR[1]"] }
ClassMethod ::= [StaticModifier] 'fun' IDENTIFIER '(' [Arguments] ')' '{' Statement* '}'
ClassMember ::= [StaticModifier] 'var' IDENTIFIER ['=' Expression] ';'

StaticModifier ::= 'static'

Arguments ::= Argument (',' Argument)*
Argument ::= IDENTIFIER

/* Function Statement */
FunctionStatement ::= IDENTIFIER '(' [Arguments] ')' '{' Statement* '}'
TryStatement ::= Statements 'catch' '(' IDENTIFIER ')' Statements
ForEachStatement ::= '(' IDENTIFIER ':' MemberExpression ')' Statements
ForStatement ::= '(' [Expression] ';' [Expression] ';' [Expression] ')' Statements
SwitchStatement ::= '(' Expression ')' '{' CaseStatement* '}'
CaseStatement ::= ('default' | 'case' CaseValues) '->' Statements

CaseValues ::= CaseValue (',' CaseValue)*
CaseValue ::= CaseString | CaseNumber
private CaseString ::= STRING
private CaseNumber ::= ['-'] NUMBER

/* expressions */
Expression ::= ModifyVariable
  | SizeExpression

private ModifyVariable ::= IDENTIFIER ModifyOp
private ModifyOp ::= '++' | '--' | '=' Expression

private SizeExpression ::= ComparisonExpression [SizeOp SizeExpression]
private SizeOp ::= '&&' | '||'

private ComparisonExpression ::= '!' ComparisonExpression
  | ArithmeticExpression [ComparisonOp ArithmeticExpression]
private ComparisonOp ::= '==' | '!=' | '<' | '>' | '<=' | '>='

private ArithmeticExpression ::= TermExpression [ArithmeticOp ArithmeticExpression]
private ArithmeticOp ::= '+' | '-'

private TermExpression ::= FactorExpression [TermOp TermExpression]
private TermOp ::= '*' | '/'

private FactorExpression ::= FactorOp FactorExpression
  | PowerExpression
private FactorOp ::= '+' | '-'

private PowerExpression ::= CallExpression ['^' FactorExpression]
private CallExpression ::= MemberExpression ['(' [CallArguments] ')']
private CallArguments ::= Expression (',' Expression)*
/*
private MemberExpression ::= AtomExpression [['(' [CallArguments] ')'] '.' MemberExpression]
*/
private MemberExpression ::= AtomExpression [MemberLoop]
private MemberLoop ::= '.' AtomExpression MemberOp
private MemberOp ::= '(' [CallArguments] ')' [MemberLoop]
  | '=' Expression
  | '++'
  | '--'
  | [MemberLoop]

private AtomExpression ::= Atom
  | '[' [ListElements] ']'
  | '{' [MapElements] '}'
  | FunctionLambda
  | 'new' IDENTIFIER '(' [CallArguments] ')'
  | '(' Expression ')'

FunctionLambda ::= 'fun' '(' [Arguments] ')' '{' Statement* '}'
Atom ::= IDENTIFIER
  | VALUE_KEYWORD
  | STRING
  | NUMBER

private ListElements ::= Expression (',' Expression)*
private MapElements ::= Expression ':' Expression (',' Expression ':' Expression)*