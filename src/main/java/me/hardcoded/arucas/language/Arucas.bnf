{
  parserClass="me.hardcoded.arucas.language.ArucasParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Arucas"
  psiImplClassSuffix="Impl"
  psiPackage="me.hardcoded.arucas.psi"
  psiImplPackage="me.hardcoded.arucas.psi.impl"

  elementTypeHolderClass="me.hardcoded.arucas.psi.ArucasTypes"
  elementTypeClass="me.hardcoded.arucas.psi.ArucasElementType"
  tokenTypeClass="me.hardcoded.arucas.psi.ArucasTokenType"

  tokens = [
    COMMENT='regexp://.*[^\n\r\f]|/\*(.|[\r\n\f])*?\*/'
    WHITESPACE='regexp:\s+'
    NUMBER='regexp:[0-9]+(\\.[0-9]+)?'
    KW_TRUE="true"
    KW_FALSE="false"
    KW_NULL="null"
    KW_THIS="this"
    KW_IF="if"
    KW_ELSE="else"
    KW_FOR="for"
    KW_FOREACH="foreach"
    KW_WHILE="while"
    KW_TRY="try"
    KW_CATCH="catch"
    KW_FUN="fun"
    KW_CLASS="class"
    KW_OPERATOR="operator"
    KW_NEW="new"
    KW_STATIC="static"
    KW_VAR="var"
    KW_SWITCH="switch"
    KW_CASE="case"
    KW_DEFAULT="default"
    KW_RETURN="return"
    KW_BREAK="break"
    KW_CONTINUE="continue"
    IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")|(\"([^\"\\]|\\.)*\"|'([^'\\]|\\.)*\")"
    OP_LOGICAL_OR="||"
    OP_LOGICAL_AND="&&"
    OP_EQUALS="=="
    OP_NOTEQUALS="!="
    OP_MORETHANEQ=">="
    OP_MORETHAN=">"
    OP_LESSTHANEQ="<="
    OP_LESSTHAN="<"
    OP_PLUS="+"
    OP_MINUS="-"
    OP_MUL="*"
    OP_DIV="/"
    OP_POW="^"
    OP_NOT="!"
    OP_MM="--"
    OP_PP="++"
    COMMA=","
    SEMICOLON=";"
    ASSIGNMENT="="
    POINTER="->"
    DOT="."
    COLON=":"
    LPAREN="("
    RPAREN=")"
    LBRACK="["
    RBRACK="]"
    LBRACE="{"
    RBRACE="}"
  ]
}

// ROOT
arucas ::= Statement *

CodeBlock ::= '{' ( '}' | Statement+ '}' )
Statement ::= CodeBlock
  | ';'
  | IfStatement
  | WhileStatement
  | ClassDeclaration
  | FunctionStatement
  | TryStatement
  | ForEachStatement
  | ForStatement
  | SwitchStatement
  | ReturnStatement
  | ContinueStatement
  | BreakStatement
  | ExpressionStatement

IdentifierName ::= IDENTIFIER {extends=Name}
ClassName ::= IDENTIFIER {extends=Name}
VariableName ::= IDENTIFIER {extends=Name}
FunctionName ::= IDENTIFIER {extends=Name}

fake Name ::= {
  mixin="me.hardcoded.arucas.psi.impl.ArucasNamedElementImpl"
  implements="me.hardcoded.arucas.psi.ArucasNamedElement"
  methods=[setName getNameIdentifier]
}

ReturnStatement ::= 'return' Expression? ';' {extends=Statement}
ContinueStatement ::= 'continue' ';' {extends=Statement}
BreakStatement ::= 'break' ';' {extends=Statement}
ExpressionStatement ::= Expression ';' {extends=Statement pin=1}

IfStatement ::= 'if' '(' Expression ')' Statement ElseStatement? {extends=Statement}
ElseStatement ::= 'else' Statement {extends=Statement}
WhileStatement ::= 'while' '(' Expression ')' Statement {extends=Statement}

/* Class Statement */
ClassDeclaration ::= 'class' ClassName ClassCodeBlock {extends=Statement}
ClassCodeBlock ::= '{' ClassBodyStatement* '}' {extends=Statement}
private ClassBodyStatement ::= ClassMember
  | ClassConstructor
  | ClassMethod
  | ClassOperator {extends=Statement}

Operator ::= '+' | '-' | '*' | '/' | '^' | '!' | '==' | '!='
  | '++' | '--' | '&&' | '||' | '>=' | '<=' | '>' | '<'

ClassConstructor ::= FunctionName Arguments CodeBlock
ClassOperator ::= 'operator' Operator OperatorArguments CodeBlock { methods=[operator="OPERATOR[0]"] }
ClassMethod ::= FunctionModifiers 'fun' FunctionName Arguments CodeBlock
ClassMember ::= FunctionModifiers 'var' VariableName ['=' Expression] ';'
FunctionModifiers ::= ( 'static'? ) {
  mixin="me.hardcoded.arucas.psi.impl.ArucasModifierElementImpl"
  implements="me.hardcoded.arucas.psi.ArucasModifierElement"
  methods=[isStatic]
}

Arguments ::= '(' [ Argument (',' Argument)* ] ')'
Argument ::= IdentifierName

OperatorArguments ::= Arguments

/* Function Statement */
FunctionStatement ::= 'fun' FunctionName Arguments CodeBlock {extends=Statement}
TryStatement ::= 'try' Statement 'catch' '(' IdentifierName ')' Statement {
  extends=Statement
  methods=[
    TRY_BODY="Statement[0]"
    CATCH_BODY="Statement[1]"
  ]
}

/* For Statements */
ForEachStatement ::= 'foreach' '(' IdentifierName ':' MemberExpression ')' Statement {
  extends=Statement
}
ForStatement ::= 'for' '(' Expression? ';' Expression? ';' Expression? ')' Statement {extends=Statement}

/* Switch Statement */
SwitchStatement ::= 'switch' '(' Expression ')' SwitchCodeBlock {extends=Statement}
SwitchCodeBlock ::= '{' CaseStatement* '}' {extends=Statement}
CaseStatement ::= ('default' | 'case' CaseValues) '->' Statement

CaseValues ::= CaseValue (',' CaseValue)*
CaseValue ::= CaseString | CaseNumber
private CaseString ::= STRING
private CaseNumber ::= ['-'] NUMBER

/* Expressions */
Expression ::= AssignExpression
  | ConditionalOrExpression
  | ConditionalAndExpression
  | UnaryNotExpression
  | RelationalExpression
  | ArithmeticExpression
  | FactorExpression
  | UnaryExpression
  | PowerExpression
  | CallExpression
  | MemberExpression
  | AtomExpressionGroup

AssignExpression ::= IdentifierName ('++' | '--' | '=' Expression) {extends=Expression}
ConditionalOrExpression ::= Expression '||' Expression {extends=Expression}
ConditionalAndExpression ::= Expression '&&' Expression {extends=Expression}
RelationalExpression ::= Expression ('==' | '!=' | '<' | '>' | '<=' | '>=') Expression {extends=Expression}
ArithmeticExpression ::= Expression ('+' | '-') Expression {extends=Expression}
FactorExpression ::= Expression ('*' | '/') Expression {extends=Expression}
UnaryNotExpression ::= '!' Expression {extends=Expression}
UnaryExpression ::= ('+' | '-') Expression {extends=Expression}
PowerExpression ::= Expression '^' Expression {extends=Expression}
CallExpression ::= Expression &'(' CallArguments {extends=Expression}
CallArguments ::= '(' [ Expression (',' Expression)* ] ')' {pin=1}
MemberExpression ::= Expression '.' ( &IDENTIFIER ) Expression {
  extends=Expression
  methods=[
    LEFT="Expression[0]"
    RIGHT="Expression[1]"
  ]
}
private AtomExpressionGroup ::= AtomExpression
  | &'[' ListExpression
  | &'{' MapExpression
  | &'fun' LambdaExpression
  | &'new' NewExpression
  | &'(' ParenthesesExpression

AtomExpression ::= IdentifierName
  | ValueKeyword
  | STRING
  | NUMBER {
  extends=Expression
  mixin="me.hardcoded.arucas.psi.impl.ArucasAtomElementImpl"
  implements="me.hardcoded.arucas.psi.ArucasAtomElement"
  methods=[getAtomType]
}
private ValueKeyword ::= KW_TRUE | KW_FALSE | KW_NULL | KW_THIS

ListExpression ::= '[' ListElements? ']' {extends=Expression pin=1}
private ListElements ::= Expression (',' Expression)*
MapExpression ::= '{' MapElements? '}' {extends=Expression pin=1}
private MapElements ::= MapEntry (',' MapEntry)*
MapEntry ::= Expression ':' Expression {
  methods=[
    key="Expression[0]"
    value="Expression[1]"
  ]
}
LambdaExpression ::= 'fun' Arguments CodeBlock {extends=Expression}
NewExpression ::= 'new' ClassName CallArguments {extends=Expression}
ParenthesesExpression ::= '(' Expression ')' {extends=Expression}
