{
  parserClass="me.hardcoded.arucas.language.ArucasParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Arucas"
  psiImplClassSuffix="Impl"
  psiPackage="me.hardcoded.arucas.psi"
  psiImplPackage="me.hardcoded.arucas.psi.impl"

  elementTypeHolderClass="me.hardcoded.arucas.psi.ArucasTypes"
  elementTypeClass="me.hardcoded.arucas.psi.ArucasElementType"
  tokenTypeClass="me.hardcoded.arucas.psi.ArucasTokenType"

  tokens = [
    COMMENT='regexp://.*[^\n\r\f]|/\*(.|[\r\n\f])*?\*/'
    WHITESPACE='regexp:\s+'
    NUMBER='regexp:[0-9]+(\\.[0-9]+)?'
    VALUE_KEYWORD='regexp:true|false|null|this'
    KEYWORD='regexp:if|else|foreach|for|while|try|catch|fun|class|operator|new|static|var|switch|case|default|return|break|continue'
    IDENTIFIER='regexp:[a-zA-Z_][a-zA-Z0-9_]*'
    STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")|(\"([^\"\\]|\\.)*\"|'([^'\\]|\\.)*\")"
    SYNTAX='regexp:|==|!=|>=|<=|>|<|\|\||&&'
    OPERATOR='regexp:--|\+\+|\+|-|\*|/|\^|!'
    COMMA=','
    SEMICOLON=";"
    ASSIGNMENT="="
    POINTER="->"
    DOT="."
    COLON=":"
    LPAREN="("
    RPAREN=")"
    LBRACK="["
    RBRACK="]"
    LBRACE="{"
    RBRACE="}"
  ]
}

// ROOT
arucas ::= Statement *

CodeBlock ::= '{' ( '}' | Statement+ '}' )
Statement ::= CodeBlock
  | ';'
  | IfStatement
  | WhileStatement
  | ClassDeclaration
  | FunctionStatement
  | TryStatement
  | ForEachStatement
  | ForStatement
  | SwitchStatement
  | ReturnStatement
  | ContinueStatement
  | BreakStatement
  | ExpressionStatement

ReturnStatement ::= 'return' SizeExpression? ';' {extends=Statement}
ContinueStatement ::= 'continue' ';' {extends=Statement}
BreakStatement ::= 'break' ';' {extends=Statement}
ExpressionStatement ::= Expression ';' {extends=Statement}

IfStatement ::= 'if' '(' Expression ')' Statement ElseStatement? {extends=Statement}
ElseStatement ::= 'else' Statement {extends=Statement}
WhileStatement ::= 'while' '(' Expression ')' Statement {extends=Statement}

/* Class Statement */
ClassDeclaration ::= 'class' IDENTIFIER ClassCodeBlock {extends=Statement}
ClassCodeBlock ::= '{' ClassBodyStatement* '}' {extends=Statement}
private ClassBodyStatement ::= ClassMember
  | ClassConstructor
  | ClassMethod
  | ClassOperator {extends=Statement}

ClassConstructor ::= IDENTIFIER '(' [Arguments] ')' CodeBlock
ClassOperator ::= 'operator' OPERATOR '(' [Arguments] ')' CodeBlock { methods=[operator="OPERATOR[0]"] }
ClassMethod ::= [StaticModifier] 'fun' IDENTIFIER '(' [Arguments] ')' CodeBlock
ClassMember ::= [StaticModifier] 'var' IDENTIFIER ['=' Expression] ';'
StaticModifier ::= 'static'

Arguments ::= Argument (',' Argument)*
Argument ::= IDENTIFIER

/* Function Statement */
FunctionStatement ::= 'fun' IDENTIFIER '(' Arguments? ')' CodeBlock {extends=Statement}
TryStatement ::= 'try' Statement 'catch' '(' IDENTIFIER ')' Statement {
  extends=Statement
  methods=[
    TRY_BODY="Statement[0]"
    CATCH_BODY="Statement[1]"
  ]
}

/* For Statements */
ForEachStatement ::= 'foreach' '(' IDENTIFIER ':' MemberExpression ')' Statement {extends=Statement}
ForStatement ::= 'for' '(' Expression? ';' Expression? ';' Expression? ')' Statement {extends=Statement}

/* Switch Statement */
SwitchStatement ::= 'switch' '(' Expression ')' SwitchCodeBlock {extends=Statement}
SwitchCodeBlock ::= '{' CaseStatement* '}' {extends=Statement}
CaseStatement ::= ('default' | 'case' CaseValues) '->' Statement

CaseValues ::= CaseValue (',' CaseValue)*
CaseValue ::= CaseString | CaseNumber
private CaseString ::= STRING
private CaseNumber ::= ['-'] NUMBER

/* Expressions */
Expression ::= ModifyVariable
  | SizeExpression

// TODO: Make these into two groups Binary and Unary
private ModifyVariable ::= IDENTIFIER ModifyOp
private ModifyOp ::= '++' | '--' | '=' Expression

private SizeExpression ::= ComparisonExpression [SizeOp SizeExpression]
private SizeOp ::= '&&' | '||'

private ComparisonExpression ::= '!' ComparisonExpression
  | ArithmeticExpression [ComparisonOp ArithmeticExpression]
private ComparisonOp ::= '==' | '!=' | '<' | '>' | '<=' | '>='

private ArithmeticExpression ::= TermExpression [ArithmeticOp ArithmeticExpression]
private ArithmeticOp ::= '+' | '-'

private TermExpression ::= FactorExpression [TermOp TermExpression]
private TermOp ::= '*' | '/'

private FactorExpression ::= FactorOp FactorExpression
  | PowerExpression
private FactorOp ::= '+' | '-'

private PowerExpression ::= CallExpression ['^' FactorExpression]
private CallExpression ::= MemberExpression ['(' [CallArguments] ')']
private CallArguments ::= Expression (',' Expression)*

private MemberExpression ::= AtomExpression [MemberLoop]
private MemberLoop ::= '.' AtomExpression MemberOp
private MemberOp ::= '(' [CallArguments] ')' [MemberLoop]
  | '=' Expression
  | '++'
  | '--'
  | [MemberLoop]

private AtomExpression ::= Atom
  | ListExpression
  | MapExpression
  | FunctionLambda
  | NewExpression
  | '(' Expression ')'

// TODO: Add recovery tokens
ListExpression ::= '[' [ListElements] ']' {extends=Expression}
private ListElements ::= Expression (',' Expression)*
MapExpression ::= '{' [MapElements] '}' {extends=Expression}
private MapElements ::= MapEntry (',' MapEntry)*
MapEntry ::= Expression ':' Expression {
  methods=[
    key="Expression[0]"
    value="Expression[1]"
  ]
}

NewExpression ::= 'new' IDENTIFIER '(' [CallArguments] ')' {extends=Expression}
FunctionLambda ::= 'fun' '(' [Arguments] ')' CodeBlock {extends=Expression}
Atom ::= IDENTIFIER
  | VALUE_KEYWORD
  | STRING
  | NUMBER {extends=Expression}
